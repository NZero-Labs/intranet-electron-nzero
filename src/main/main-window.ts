import {
  App,
  app,
  BrowserWindow,
  clipboard,
  dialog,
  ipcMain,
  net,
  Notification,
  protocol,
  Session,
  session
} from 'electron'
import path from 'path'
import { unlink } from 'fs'
import { is } from '@electron-toolkit/utils'
import {
  addNewTab,
  getSelectedTab,
  restoreTabs,
  saveTabs,
  setFilePath,
  setRightClickText,
  showContent
} from '~/main/tabs'
import { createToolbar, getToolbar } from '~/main/toolbar'
import { DownloadPayloadProps, SendNotificationProps } from '~/main/types'
import { SITE_URL } from '~/main/url-helpers'

let baseWindow: BrowserWindow | null = null
let ses: Session | null = null
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string

const handleProtocol = (request: GlobalRequest) => {
  const fileUrl = request.url.replace('static://', '')
  const filePath = path.join(app.getAppPath(), '.webpack/main', fileUrl)
  return net.fetch(filePath)
}
export async function initializeMainWindow() {
  protocol.handle('static', handleProtocol)
  ses = session.fromPartition('persist:myprofile')
  ses.protocol.handle('static', handleProtocol)
  // Create the browser window.
  const icon = path.join(__dirname, './assets/icon.ico')
  baseWindow = new BrowserWindow({
    width: 1600,
    height: 900,
    minWidth: 1280,
    show: false,
    frame: false, // Important: disables native title bar
    backgroundColor: '#11101d',
    autoHideMenuBar: true,
    icon,
    titleBarOverlay: true,
    trafficLightPosition: {
      x: 9,
      y: 9
    },
    webPreferences: {
      session: ses,
      devTools: false,
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: true,
      contextIsolation: false
    },
    ...(process.platform === 'darwin'
      ? { titleBarStyle: 'hiddenInset' }
      : { titleBarStyle: 'customButtonsOnHover' })
  })
  setupMainWindowEventHandlers()

  const toolbar = await createToolbar()
  const mainContent = await restoreTabs()

  if (mainContent === null || toolbar === null) {
    console.error('Failed to load toolbar or mainContent')
    return
  }

  showContent(mainContent)
  mainContent.webContents.focus()
  showWindow()

  baseWindow.contentView.addChildView(toolbar)
  baseWindow.contentView.addChildView(mainContent)

  const handleWindowChange = (type: string) => () => {
    if (!toolbar) return
    if (type === 'restored') toolbar.webContents.send('isRestored')
    if (type === 'maximized') toolbar.webContents.send('isMaximized')
  }

  toolbar.webContents.send('isLoading', true)

  baseWindow.on('will-resize', handleWindowChange('will-resize'))
  baseWindow.on('maximize', handleWindowChange('maximized'))
  baseWindow.on('unmaximize', handleWindowChange('restored'))
  ipcMain.on('reinicializeApp', () => {
    const appName = app.getName()
    const appPath = path.join(app.getPath('appData'), appName)
    unlink(appPath, async () => {
      await session.defaultSession.clearStorageData()
      await session.defaultSession.clearCache()
      app.relaunch()
      app.exit()
    })
  })

  ipcMain.on('minimizeApp', () => {
    baseWindow.minimize()
  })

  ipcMain.on('maximizeApp', () => {
    if (baseWindow.isMaximized()) {
      baseWindow.restore()
    } else {
      baseWindow.maximize()
    }
  })
  ipcMain.on('closeApp', () => {
    baseWindow.close()
  })

  baseWindow.once('ready-to-show', () => {
    baseWindow.show()
  })
  function handleDownload(payload: DownloadPayloadProps) {
    const properties = payload.properties || {}
    const defaultPath = app.getPath(
      (properties.directory || 'documents') as Parameters<App['getPath']>[0]
    )
    const defaultFileName =
      properties.filename || payload.url?.split('?')[0]?.split('/').pop() || 'download'

    const customURL = dialog.showSaveDialogSync({
      defaultPath: `${defaultPath}/${defaultFileName}`
    })

    if (customURL) {
      setFilePath(customURL)
      const selectedTab = getSelectedTab()
      selectedTab.webContents.downloadURL(payload.url)
    }
  }
  ipcMain.on('download', (e, { payload }: { payload: DownloadPayloadProps }) =>
    handleDownload(payload)
  )
  ipcMain.on('reloadApp', () => {
    const selectedTab = getSelectedTab()
    selectedTab?.webContents?.reload()
  })
  ipcMain.on('backApp', () => {
    const selectedTab = getSelectedTab()
    if (selectedTab?.webContents?.navigationHistory?.canGoBack()) {
      selectedTab?.webContents?.navigationHistory?.goBack()
    }
  })
  ipcMain.on('forwardApp', () => {
    const selectedTab = getSelectedTab()
    if (selectedTab?.webContents?.navigationHistory?.canGoForward()) {
      selectedTab?.webContents?.navigationHistory?.goForward()
    }
  })
  ipcMain.on('rightClickApp', (e, el) => {
    setRightClickText(el)
  })
  ipcMain.on('copied-table', () => {
    const toolBar = getToolbar()
    toolBar.webContents.send('copied-table')
  })

  ipcMain.on('send-notification', (e, notificationOptions: SendNotificationProps) => {
    try {
      const notification = new Notification(notificationOptions)
      if (notificationOptions.urlNotify) {
        notification.on('click', () => {
          addNewTab(notificationOptions.urlNotify.replace(SITE_URL, ''))
        })
      }
      notification.show()
    } catch (error) {
      console.error('Erro ao enviar notificação:', error)
    }
  })
  ipcMain.on('copyText', (e, text) => {
    clipboard.writeText(text)
    const abortController = new AbortController()
    dialog
      .showMessageBox(null, {
        type: 'info',
        signal: abortController.signal,
        title: 'Texto Copiado!',
        message: 'O Texto foi copiado:',
        detail: text.length > 20 ? `${text.slice(0, 20)}...` : text,
        icon: path.join(__dirname, 'favicon.ico')
      })
      .catch(() => console.error('Error getting text'))
    setTimeout(() => abortController.abort(), 1000)
  })

  ipcMain.on('send-close-tab', () => {
    const toolBar = getToolbar()
    toolBar.webContents.send('close-current-tab')
  })
}

/**
 * Configures event handlers for window resizing, movement, and application lifecycle events.
 * Handles window state persistence and platform-specific behaviors (Mac/Windows).
 * @param baseWindow - The main application window instance
 */
function setupMainWindowEventHandlers() {
  app.on('activate', () => {
    showWindow()
  })

  app.on('before-quit', () => {
    saveTabs()
  })
}

/**
 * Returns the main application window instance.
 * @returns The main BaseWindow instance or null if not initialized
 */
export function getBaseWindow() {
  return baseWindow
}

/**
 * Returns the main application window instance.
 * @returns The main BaseWindow instance or null if not initialized
 */
export function getSession() {
  return ses
}

/**
 * Shows the main application window.
 * Handles different behavior for development and production environments.
 */
export function showWindow() {
  if (!baseWindow) {
    return
  }

  //? This is to prevent the window from gaining focus everytime we make a change in code.
  if (!is.dev && !process.env['ELECTRON_RENDERER_URL']) {
    baseWindow.show()
    return
  }

  if (!baseWindow.isVisible()) {
    baseWindow.show()
  }
}
