import { app, BrowserWindow, clipboard, dialog, ipcMain, Menu, net, Notification, NotificationConstructorOptions, protocol, session, Tray, WebContentsView } from 'electron';
import { updateElectronApp } from 'update-electron-app';
import path from 'path';
import { unlink } from 'fs';
import contextMenu from 'electron-context-menu';
import log from 'electron-log/main';

log.initialize();
Object.assign(console, log.functions);
export type DownloadPayloadProps = {properties: {filename?: string, directory?: Parameters<typeof app.getPath>[0]}, url: string}
export type SendNotificationProps = NotificationConstructorOptions & { urlNotify: string }
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
const HEADER_HEIGHT = 40;


const SITE_URL = "https://10.10.10.5";
let rightClickText = "";
let filePath = "";


console.log("__dirname", __dirname)
// updateElectronApp();

if (process.defaultApp) {
  if (process.argv.length >= 2) {
    app.setAsDefaultProtocolClient("intranet", process.execPath, [
      path.resolve(process.argv[1]),
    ]);
  }
} else {
  app.setAsDefaultProtocolClient("intranet");
}
// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}
const handleProtocol = (request: GlobalRequest) => {
  const fileUrl = request.url.replace('static://', '');
  const filePath = path.join(app.getAppPath(), '.webpack/renderer', fileUrl);
  return net.fetch(filePath);
}
const createWindow = (): void => {
  protocol.handle('static', handleProtocol);
  const ses = session.fromPartition('persist:myprofile');
  ses.protocol.handle('static', handleProtocol);
  // Create the browser window.
  const win = new BrowserWindow({
    width: 1600,
    height: 900,
    minWidth: 1280,
    show: false,
    frame: false, // Important: disables native title bar
    backgroundColor: "#11101d",
    icon: path.join(__dirname, "./assets/icon.ico"),
    titleBarStyle: "customButtonsOnHover",
    titleBarOverlay: true,
    webPreferences: {
      session: ses,
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: true,
      contextIsolation: false,
      allowRunningInsecureContent: true,
    },
  });
  const view = new WebContentsView({
    webPreferences: {
      session: ses,
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: true,
      contextIsolation: false,
      spellcheck: true,
      allowRunningInsecureContent: true,
      webSecurity: false, 
    },
  });
  function browserViewOpening(viewPath = "") {
    if (view && win) {
      const contentBounds = win.getContentBounds();
      view.setBounds({
        x: 0,
        y: HEADER_HEIGHT,
        width: contentBounds.width,
        height: contentBounds.height - HEADER_HEIGHT,
      });
      console.log("SITE_URL", `${SITE_URL}${viewPath}`)
      view.webContents.loadURL(`${SITE_URL}${viewPath}`);
      view.webContents.session.setSpellCheckerLanguages(['en-US', 'en', 'pt-BR']);
    }
  }
  const handleWindowChange = () => {
    const bounds = win.getContentBounds();
    view.setBounds({
      x: 0,
      y: HEADER_HEIGHT,
      width: bounds.width,
      height: bounds.height - HEADER_HEIGHT,
    });
  };
  function handleDownload(payload: DownloadPayloadProps) {
    const properties = payload.properties || {};
    const defaultPath = app.getPath(properties.directory || "documents");
    const defaultFileName =
      properties.filename ||
      payload.url?.split("?")[0]?.split("/").pop() ||
      "download";
  
    const customURL = dialog.showSaveDialogSync({
      defaultPath: `${defaultPath}/${defaultFileName}`,
    });
  
    if (customURL) {
      filePath = customURL;
      view.webContents.downloadURL(payload.url);
    }
  }
  contextMenu({
    window: view.webContents,
    showCopyImage: true,
    showSaveImage: true,
    prepend: () => [
      {
        label: "Copiar Texto",
        visible: Boolean(rightClickText),
        click: () => {
          if (rightClickText) {
            clipboard.writeText(rightClickText);
            const abortController = new AbortController();
            dialog
              .showMessageBox(null, {
                type: "info",
                signal: abortController.signal,
                title: "Texto Copiado!",
                message: "O Texto foi copiado:",
                detail:
                  rightClickText.length > 20
                    ? `${rightClickText.slice(0, 20)}...`
                    : rightClickText,
                icon: path.join(__dirname, "favicon.ico"),
              })
              .catch(() => console.error("Error getting text"));
            setTimeout(() => abortController.abort(), 1500);
          }
        },
      },
    ],
    labels: {
      copy: "Copiar",
      copyImage: "Copiar imagem",
      copyImageAddress: "Copiar endereço da imagem",
      copyLink: "Copiar endereço do link",
      saveImage: "Salvar imagem",
      saveImageAs: "Salvar imagem como...",
      selectAll: "Selecionar tudo",
    },
  });
  const tray = new Tray(path.join(__dirname, "./assets/icon.ico"))
  tray.setToolTip('Intranet Amaranzero')
  win.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
  browserViewOpening();
  win.contentView.addChildView(view)
  const trayContextMenu = Menu.buildFromTemplate([
    { label: 'Abrir Open DevTools', type: 'normal', click: () => view.webContents.openDevTools() }
  ])
  tray.setContextMenu(trayContextMenu)
  win.webContents.send("isLoading", true);

  win.on("will-resize", handleWindowChange);
  win.on("maximize", handleWindowChange);
  win.on("unmaximize", handleWindowChange);

  const handleLoading = (isLoading: boolean) => () => {
    win.webContents.send("arrow-navigation", {
      canGoBack: view.webContents.navigationHistory.canGoBack(),
      canGoForward: view.webContents.navigationHistory.canGoForward(),
    });
    win.webContents.send("isLoading", isLoading);
  };

  view.webContents.on("did-start-loading", handleLoading(true));
  view.webContents.on("did-stop-loading", handleLoading(false));
  view.webContents.on("will-navigate", handleLoading(true));
  view.webContents.on("did-navigate", handleLoading(false));

  view.webContents.zoomFactor = 1;
  view.webContents.setVisualZoomLevelLimits(1, 5).catch(console.error);
  view.webContents.on("zoom-changed", (_, zoomDirection) => {
    const currentZoom = view.webContents.getZoomFactor();

    if (zoomDirection === "in") {
      view.webContents.zoomFactor = currentZoom + 0.2;
    }
    if (zoomDirection === "out") {
      view.webContents.zoomFactor = currentZoom - 0.2;
    }
  });
  // view.webContents.on('did-fail-load', (event, errorCode, errorDescription, validatedURL) => {
  //   log.error(`Failed to load ${validatedURL}: ${errorDescription} (${errorCode})`);
  // });

  view.webContents.session.on("will-download", (event, item) => {
    if (filePath) item.setSavePath(filePath);
  });
  ipcMain.on("download", (e, { payload }: { payload: DownloadPayloadProps }) => handleDownload(payload));
  ipcMain.on("send-notification", (e, notificationOptions: SendNotificationProps) => {
    try {
      const notification = new Notification(notificationOptions);
      if (notificationOptions.urlNotify) {
        notification.on("click", () => {
          browserViewOpening(notificationOptions.urlNotify);
        });
      }
      notification.show();
    } catch (error) {
      console.error("Erro ao enviar notificação:", error);
    }
  });
  ipcMain.on("reinicializeApp", () => {
    const appName = app.getName();
    const appPath = path.join(app.getPath("appData"), appName);
    unlink(appPath, async () => {
      await session.defaultSession.clearStorageData();
      await session.defaultSession.clearCache();
      app.relaunch();
      app.exit();
    });
  });

  ipcMain.on("reloadApp", () => view.webContents.reload());
  ipcMain.on("backApp", () => {
    if (view.webContents.navigationHistory.canGoBack()) {
      view.webContents.navigationHistory.goBack();
    }
  });
  ipcMain.on("forwardApp", () => {
    if (view.webContents.navigationHistory.canGoForward()) {
      view.webContents.navigationHistory.goForward();
    }
  });
  ipcMain.on("minimizeApp", () => {
    win.minimize();
  });

  ipcMain.on("maximizeApp", () => {
    if (win.isMaximized()) {
      win.restore();
    } else {
      win.maximize();
    }
  });
  ipcMain.on("closeApp", () => {
    win.close();
  });

  ipcMain.on("rightClickApp", (e, el) => {
    rightClickText = el;
  });
  ipcMain.on("copyText", (e, text) => {
    clipboard.writeText(text);
    const abortController = new AbortController();
    dialog
      .showMessageBox(null, {
        type: "info",
        signal: abortController.signal,
        title: "Texto Copiado!",
        message: "O Texto foi copiado:",
        detail: text.length > 20 ? `${text.slice(0, 20)}...` : text,
        icon: path.join(__dirname, "favicon.ico"),
      })
      .catch(() => console.error("Error getting text"));
    setTimeout(() => abortController.abort(), 1000);
  });

  win.once("ready-to-show", () => {
    win.show();
  });

  // view.webContents.openDevTools();
  // win.webContents.openDevTools();
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);
// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
